
# interthread

> "The basic idea behind an actor is to spawn a 
self-contained task that performs some job independently
of other parts of the program. Typically these actors
communicate with the rest of the program through 
the use of message passing channels. Since each actor 
runs independently, programs designed using them are 
naturally parallel."
> - Alice Ryhl 


For a comprehensive understanding of the underlying
concepts and implementation details of the Actor Model,  
it's recommended to read the article  [Actors with Tokio](https:/ryhl.io/blog/actors-with-tokio/)
 by Alice Ryhl ( also known as _Darksonn_ ). 
This article not only inspired the development of the 
`interthread` crate but also serves as foundation 
for the Actor Model implementation logic in it. 


## What is the problem ?

To achieve parallel execution of individual objects 
within the same program, it is challenging due 
to the need for various types that are capable of 
working across threads. The main difficulty 
lies in the fact that as you introduce thread-related types,
you can quickly lose sight of the main program 
idea as the focus shifts to managing thread-related 
concerns.
It involves using constructs like threads, locks, channels,
and other synchronization primitives. These additional 
types and mechanisms introduce complexity and can obscure 
the core logic of the program.


Moreover, existing libraries like [`actix`](https://docs.rs/actixlatest/actix/), [`axiom`](https://docs.rs/axiom/latest/axiom/), 
designed to simplify working within the Actor Model,
often employ specific concepts, vocabulary, traits and types thatmay
be unfamiliar to users who are less experienced with 
asynchronous programming and futures. 

## Solution 
 
The [`actor`](./attr.actor.html) macro -  when applied to the 
implementation block of a given "MyActor" object,
generates additional types and functions 
that enable communication between threads.

A notable outcome of applying this macro is the 
creation of the `MyActorLive` struct ("ActorName" + "Live"),
which acts as an interface/handle to the `MyActor` object.
`MyActorLive` retains the exact same public method signatures
as `MyActor`, allowing users to interact with the actor as if 
they were directly working with the original object.

### Examples

```rust

pub struct MyActor {
    value: i8,
}

#[interthread::actor(channel=2)] // <-  this is it 
impl MyActor {

    pub fn new( v: i8 ) -> Self {
       Self { value: v } 
    }
    pub fn increment(&mut self) {
        self.value += 1;
    }
    pub fn add_number(&mut self, num: i8) -> i8 {
        self.value += num;
        self.value
    }
    pub fn get_value(&self) -> i8 {
        self.value
    }
}
 
fn main() {

    let actor = MyActorLive::new(5);

    let mut actor_a = actor.clone();
    let mut actor_b = actor.clone();

    let handle_a = std::thread::spawn( move || { 
    actor_a.increment();
    });

    let handle_b = std::thread::spawn( move || {
    actor_b.add_number(5);
    });

    let _ = handle_a.join();
    let _ = handle_b.join();

    assert_eq!(actor.get_value(), 11)
}

```
 
An essential point to highlight is that when invoking 
`MyActorLive::new`, not only does it return an instance 
of `MyActorLive`, but it also spawns a new thread that 
contains an instance of `MyActor` in it. 
This introduces parallelism to the program.

The code generated by [`actor`](./attr.actor.html) takes 
care of the underlying message routing and synchronization, 
allowing developers to rapidly prototype their application's
core functionality. This fast sketching capability is
particularly useful when exploring different design options, 
experimenting with concurrency models, or implementing 
proof-of-concept systems.

For more details, check out `interthread` on 
[Docs.rs](https://docs.rs/interthread#sdpl).

