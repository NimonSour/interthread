


//! # Intro
//!
//! This document covers the usage of the crate's macros, it does 
//! not delve into the detailed logic of the generated code.
//! 
//! For a comprehensive understanding of the underlying
//! concepts and implementation details of the Actor Model,  
//! it's recommended to read the article  [Actors with Tokio](https://ryhl.io/blog/actors-with-tokio/)
//! by Alice Ryhl ( also known as _Darksonn_ ) also a great 
//! talk by the same author on the same subject if a more 
//! interactive explanation is prefered 
//! [Actors with Tokio – a lesson in ownership - Alice Ryhl](https://www.youtube.com/watch?v=fTXuGRP1ee4)
//! (video).
//! This article not only inspired the development of the 
//! `interthread` crate but also serves as foundation 
//! for the Actor Model implementation logic in it. 


//! ## What is an Actor ?
//!
//! Despite being a fundamental concept in concurrent programming,
//! defining exactly what an actor is can be ambiguous.
//! 
//! - *Carl Hewitt*, often regarded as the father of the Actor Model,
//! [The Actor Model](https://www.youtube.com/watch?v=7erJ1DV_Tlo) (video).
//! 
//! - Wikipidia [Actor Model](https://en.wikipedia.org/wiki/Actor_model)
//!  
//!
//! a quote from [Actors with Tokio](https://ryhl.io/blog/actors-with-tokio/):
//! 
//! > "The basic idea behind an actor is to spawn a 
//! self-contained task that performs some job independently
//! of other parts of the program. Typically these actors
//! communicate with the rest of the program through 
//! the use of message passing channels. Since each actor 
//! runs independently, programs designed using them are 
//! naturally parallel."
//! > - Alice Ryhl 
//!
//! ## What is the problem ?
//! 
//! To achieve parallel execution of individual objects 
//! within the same program, it is challenging due 
//! to the need for various types that are capable of 
//! working across threads. The main difficulty 
//! lies in the fact that as you introduce thread-related types,
//! you can quickly lose sight of the main program 
//! idea as the focus shifts to managing thread-related 
//! concerns.
//!
//! It involves using constructs like threads, locks, channels,
//! and other synchronization primitives. These additional 
//! types and mechanisms introduce complexity and can obscure 
//! the core logic of the program.
//! 
//! 
//! Moreover, existing libraries like [`actix`](https://docs.rs/actix/latest/actix/), [`axiom`](https://docs.rs/axiom/latest/axiom/), 
//! designed to simplify working within the Actor Model,
//! often employ specific concepts, vocabulary, traits and types that may
//! be unfamiliar to users who are less experienced with 
//! asynchronous programming and futures. 
//! 
//! ## Solution 
//! 
//! The [`actor`](./attr.actor.html) macro -  when applied to the 
//! implementation block of a given "MyActor" object,
//! generates additional Struct types  
//! that enable communication between threads.
//! 
//! A notable outcome of applying this macro is the 
//! creation of the `MyActorLive` struct ("ActorName" + "Live"),
//! which acts as an interface/handle to the `MyActor` object.
//! `MyActorLive` retains the exact same public method signatures
//! as `MyActor`, allowing users to interact with the actor as if 
//! they were directly working with the original object.
//! 
//! ### Examples
//! 
//! 
//! Filename: Cargo.toml
//! 
//!```text
//![dependencies]
//!interthread = "1.1.7"
//!oneshot     = "0.1.5" 
//!```
//! 
//! Filename: main.rs
//!```rust
//!pub struct MyActor {
//!    value: i8,
//!}
//!
//!#[interthread::actor(channel=2)] // <-  this is it 
//!impl MyActor {
//!
//!    pub fn new( v: i8 ) -> Self {
//!       Self { value: v } 
//!    }
//!    pub fn increment(&mut self) {
//!        self.value += 1;
//!    }
//!    pub fn add_number(&mut self, num: i8) -> i8 {
//!        self.value += num;
//!        self.value
//!    }
//!    pub fn get_value(&self) -> i8 {
//!        self.value
//!    }
//!}
//! // uncomment to see the generated code
//! //#[interthread::example(path="src/main.rs")]  
//!fn main() {
//!
//!    let actor = MyActorLive::new(5);
//!
//!    let mut actor_a = actor.clone();
//!    let mut actor_b = actor.clone();
//!
//!    let handle_a = std::thread::spawn( move || { 
//!    actor_a.increment();
//!    });
//!
//!    let handle_b = std::thread::spawn( move || {
//!    actor_b.add_number(5);
//!    });
//!
//!    let _ = handle_a.join();
//!    let _ = handle_b.join();
//!
//!    assert_eq!(actor.get_value(), 11)
//!}
//!
//! ```
//! 
//! An essential point to highlight is that when invoking 
//! `MyActorLive::new`, not only does it return an instance 
//! of `MyActorLive`, but it also spawns a new thread that 
//! contains an instance of `MyActor` in it. 
//! This introduces parallelism to the program.
//! 
//! The code generated by the [`actor`](./attr.actor.html) takes 
//! care of the underlying message routing and synchronization, 
//! allowing developers to rapidly prototype their application's
//! core functionality. This fast sketching capability is
//! particularly useful when exploring different design options, 
//! experimenting with concurrency models, or implementing 
//! proof-of-concept systems. Not to mention, the cases where 
//! the importance of the program lies in the result of its work 
//! rather than its execution.
//!
//! 
//! # SDPL Framework
//! 
//! 
//!  The code generated by the [`actor`](./attr.actor.html) macro 
//! can be divided into four more or less important but distinct 
//! parts: [`script`](#script) ,[`direct`](#direct), 
//! [`play`](#play), [`live`](#live) .
//! 
//!  This categorization provides an intuitive 
//! and memorable way to understand the different aspects 
//! of the generated code.
//! 
//! Expanding the above example, uncomment the [`example`](./attr.example.html)
//! placed above the `main` function, go to `examples/inter/main.rs` in your 
//! root directory and find `MyActor` along with additional SDPL parts :
//! 
//! # `script`
//! 
//!  Think of script as a message type definition.
//! 
//!  The declaration of an `ActorName + Script` enum, which is 
//! serving as a collection of variants that represent 
//! different messages that may be sent across threads through a
//! channel. 
//! 
//!  Each variant corresponds to a struct with fields
//! that capture the input and/or output parameters of 
//! the respective public methods of the Actor.
//!  
//! 
//! ```rust
//! 
//!pub enum MyActorScript {
//!    Increment {},
//!    AddNumber {
//!        input: (i8),
//!        output: oneshot::Sender<i8>,
//!    },
//!    GetValue {
//!        output: oneshot::Sender<i8>,
//!    },
//!}
//! 
//! ```
//! 
//! > **Note**: Method `new` not included as a variant in the `script`. 
//! 
//! 
//! # direct
//! The implementation block of `script`struct, specifically 
//! the `direct` method which allows 
//! for direct invocation of the Actor's methods by mapping 
//! the enum variants to the corresponding function calls.
//! 
//! 
//!```rust
//!impl MyActorScript {
//!    pub fn direct(self, actor: &mut MyActor) {
//!        match self {
//!            MyActorScript::Increment {} => {
//!                actor.increment();
//!            }
//!            MyActorScript::AddNumber {
//!                input: (num),
//!                output: send,
//!            } => {
//!                send.send(actor.add_number(num))
//!                    .expect("'my_actor_direct.send'. Channel closed");
//!            }
//!            MyActorScript::GetValue { output: send } => {
//!                send.send(actor.get_value())
//!                    .expect("'my_actor_direct.send'. Channel closed");
//!            }
//!        }
//!    }
//!}
//!```
//! 
//! # play
//! The implementation block of `script`struct, specifically 
//! the `play` associated (static) method responsible for 
//! continuously receiving `script` variants from 
//! a dedicated channel and `direct`ing them.
//! 
//! Also this function serves as the home for the Actor itself.
//! 
//! 
//!```rust
//!impl MyActorScript { 
//!    pub fn play(
//!        receiver: std::sync::mpsc::Receiver<MyActorScript>, 
//!        mut actor: MyActor) {
//!     
//!        while let Ok(msg) = receiver.recv() {
//!            msg.direct(&mut actor);
//!        }
//!        eprintln!("MyActor end of life ...");
//!    }
//!}
//!``` 
//! 
//! When using the [`edit`](./attr.actor.html#edit) argument in the [`actor`](./attr.actor.html) 
//! macro, such as 
//! 
//!```rust
//!#[interthread::actor(channel=2, edit(script(imp(play))))]
//!``` 
//! 
//! it allows for manual implementation of the `play` part, which 
//! gives the flexibility to customize and modify 
//! the behavior of the `play` to suit any requared logic.
//! 
//! In addition the Debug trait is also implemented for the `script`struct.
//!  
//! ```rust
//!impl std::fmt::Debug for MyActorScript {
//!    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//!        match self {
//!            MyActorScript::Increment { .. } => write!(f, "MyActorScript::Increment"),
//!            MyActorScript::AddNumber { .. } => write!(f, "MyActorScript::AddNumber"),
//!            MyActorScript::GetValue { .. } => write!(f, "MyActorScript::GetValue"),
//!        }
//!    }
//!}
//! ```
//! 
//! 
//! # live
//! A struct `ActorName + Live`, which serves as an interface/handler 
//! replicating the public method signatures of the original Actor.
//! 
//! Invoking a method on a live instance, it's triggering the eventual 
//! invocation of the corresponding method within the Actor. 
//! 
//! The special method of `live` method `new`  
//! - declares a new channel
//! - initiates an instace of the Actor
//! - spawns the `play` component in a separate thread 
//! - returns an instance of `Self`
//! 
//! 
//! ```rust 
//! 
//!#[derive(Clone)]
//!pub struct MyActorLive {
//!    sender: std::sync::mpsc::SyncSender<MyActorScript>,
//!}
//!impl MyActorLive {
//!    pub fn new(v: i8) -> Self {
//!        let (sender, receiver) = std::sync::mpsc::sync_channel(2);
//!        let actor = MyActor::new(v);
//!        let actor_live = Self { sender };
//!        std::thread::spawn(|| { MyActorScript::play(receiver, actor) });
//!        actor_live
//!    }
//!    pub fn increment(&mut self) {
//!        let msg = MyActorScript::Increment {};
//!        let _ = self
//!            .sender
//!            .send(msg)
//!            .expect("'MyActorLive::method.send'. Channel is closed!");
//!    }
//!    pub fn add_number(&mut self, num: i8) -> i8 {
//!        let (send, recv) = oneshot::channel();
//!        let msg = MyActorScript::AddNumber {
//!            input: (num),
//!            output: send,
//!        };
//!        let _ = self
//!            .sender
//!            .send(msg)
//!            .expect("'MyActorLive::method.send'. Channel is closed!");
//!        recv.recv().expect("'MyActorLive::method.recv'. Channel is closed!")
//!    }
//!    pub fn get_value(&self) -> i8 {
//!        let (send, recv) = oneshot::channel();
//!        let msg = MyActorScript::GetValue {
//!            output: send,
//!        };
//!        let _ = self
//!            .sender
//!            .send(msg)
//!            .expect("'MyActorLive::method.send'. Channel is closed!");
//!        recv.recv().expect("'MyActorLive::method.recv'. Channel is closed!")
//!    }
//!}
//! 
//! ```
//! The methods of `live` type have same method signature
//! as Actor's own methods 
//! - declare a `oneshot` channel
//! - declare a `msg` specific `script` variant
//! - send the `msg` via `live`'s channel 
//! - receive and return the output if any   
//! 
//! # Panics
//! 
//! If the types used for input or output for actor methods 
//! do not implement the `Send`,`Sync` `'static`  traits.
//! 
//! Additionally, the actor object itself should implement 
//! the `Send` trait, allowing it to be safely moved 
//! to another thread for execution. 
//! 
//! # Macro Implicit Dependencies
//!
//! The [`actor`](./attr.actor.html) macro generates code
//! that utilizes channels for communication. However, 
//! the macro itself does not provide any channel implementations.
//! Therefore, depending on the libraries used in your project, 
//! you may need to import additional crates.
//!
//!### Crate Compatibility
//!<table>
//!  <thead>
//!    <tr>
//!      <th>lib</th>
//!      <th><a href="https://docs.rs/oneshot">oneshot</a></th>
//!      <th><a href="https://docs.rs/async-channel">async_channel</a></th>
//!    </tr>
//!  </thead>
//!  <tbody>
//!    <tr>
//!      <td>std</td>
//!      <td style="text-align: center;">&#10003;</td>
//!      <td style="text-align: center;"><b>-</b></td>
//!    </tr>
//!    <tr>
//!      <td><a href="https://crates.io/crates/smol">smol</a></td>
//!      <td style="text-align: center;">&#10003;</td>
//!      <td style="text-align: center;">&#10003;</td>
//!    </tr>
//!    <tr>
//!      <td><a href="https://docs.rs/tokio">tokio</a></td>
//!      <td style="text-align: center;"><b>-</b></td>
//!      <td style="text-align: center;"><b>-</b></td>
//!    </tr>
//!    <tr>
//!      <td><a href="https://crates.io/crates/async-std">async-std</a></td>
//!      <td style="text-align: center;">&#10003;</td>
//!      <td style="text-align: center;"><b>-</b></td>
//!    </tr>
//!  </tbody>
//!</table>
//!
//! 
//!>**Note:** The table shows the compatibility of 
//!>the macro with different libraries, indicating whether 
//!>the dependencies are needed (✔) or not. 
//!>The macros will provide helpful messages indicating 
//!>the necessary crate imports based on your project's dependencies.
//!
//! 
//! Checkout `interthread` on [![GitHub](https://img.shields.io/badge/GitHub-%2312100E.svg?&style=plastic&logo=GitHub&logoColor=white)](https://github.com/NimonSour/interthread)
//! 

mod attribute;
mod use_macro;
mod show;
mod file;
mod actor_gen;
mod name;
mod method;
mod check;
mod error;
mod parse;
mod generics;

static INTERTHREAD: &'static str            = "interthread";
static INTER_EXAMPLE_DIR_NAME: &'static str = "INTER_EXAMPLE_DIR_NAME";
static INTER: &'static str                  = "inter";
static GROUP: &'static str                  = "group";
static ACTOR: &'static str                  = "actor";
static EXAMPLE: &'static str                = "example";
static EXAMPLES: &'static str               = "examples";

#[cfg(windows)]
const LINE_ENDING: &'static str = "\r\n";
#[cfg(not(windows))]
const LINE_ENDING: &'static str = "\n";

/// # Code transparency and exploration
///  
/// The [`example`](./attr.example.html) macro serves as a 
/// convenient tool for code transparency and exploration.
/// Automatically generating an expanded code file,
/// it provides developers with a tangible representation of
/// the code produced by the `interthread` macros. 
/// 
/// Having the expanded code readily available in the `examples/inter`
/// directory offers a few key advantages:
///  
/// - It provides a clear reference point for developers to inspect 
/// and understand the underlying code structure.
/// 
/// - The generated code file serves as a starting point for 
/// customization. Developers can copy and paste the generated code 
/// into their own project files and make custom changes as needed. 
/// This allows for easy customization of the generated actor 
/// implementation to fit specific requirements or to add additional 
/// functionality.
/// 
/// - Helps maintain a clean and focused project structure, 
/// with the `examples` directory serving as a dedicated location for 
/// exploring and experimenting with the generated code.
/// 
/// [`example`](./attr.example.html) macro helps developers to 
/// actively engage with the generated code 
/// and facilitates a smooth transition from the generated code to a 
/// customized implementation. This approach promotes code transparency,
/// customization, and a better understanding of the generated code's 
/// inner workings, ultimately enhancing the development experience 
/// when working with the `interthread` macros.
/// 
/// Consider a macro [`actor`](./attr.actor.html)  inside the project 
/// in `src/my_file.rs`.
/// 
///Filename: my_file.rs 
///```rust
///use interthread::{actor,example};
///
///pub struct Number;
///
/// // you can have "example" macro in the same file
/// // #[example(path="src/my_file.rs")]
///
///#[actor(channel=5)]
///impl Number {
///    pub fn new(value: u32) -> Self {Self}
///}
///
///```
/// 
///Filename: main.rs 
///```rust
///use interthread::example;
///#[example(path="src/my_file.rs")]
///fn main(){
///}
///
///```
/// 
/// The macro will create and write to `examples/inter/my_file.rs`
/// the content of `src/my_file.rs` with the 
/// [`actor`](./attr.actor.html) macro expanded.
/// 
/// 
///```text
///my_project/
///├── src/
///│  ├── my_file.rs      <---  macro "actor" 
///|  |
///│  └── main.rs         <---  macro "example" 
///|
///├── examples/          
///   ├── ...
///   └── inter/      
///      ├── my_file.rs   <--- expanded "src/my_file.rs"  
///```
///
/// [`example`](./attr.example.html) macro can be placed on any 
/// item in any file within your `src` directory, providing 
/// flexibility in generating example code for/from different 
/// parts of your project.
///
/// It provides two options for generating example code files: 
///  - [`mod`](##mod)  (default)
///  - [`main`](##main) 
///
/// ## mod 
/// The macro generates an example code file within the 
/// `examples/inter` directory. For example:
///
///```rust
///#[example(path="my_file.rs")]
///```
///
/// This is equivalent to:
///
///```rust
///#[example(mod(path="my_file.rs"))]
///```
///
/// The generated example code file will be located at 
/// `examples/inter/my_file.rs`.
///
/// This option provides developers with an easy way to 
/// view and analyze the generated code, facilitating code 
/// inspection and potential code reuse.
///
/// ## main 
///
/// This option is used when specifying the `main` argument 
/// in the `example` macro. It generates two files within 
/// the `examples/inter` directory: the expanded code file 
/// and an additional `main.rs` file. 
///
///```rust
///#[example(main(path="my_file.rs"))]
///```
///
/// This option is particularly useful for testing and 
/// experimentation. It allows developers to quickly 
/// run and interact with the generated code by executing:
///
///```terminal
///$ cargo run --example inter
///```
///
/// The expanded code file will be located at 
/// `examples/inter/my_file.rs`, while the `main.rs` file 
/// serves as an entry point for running the example.
/// 
/// ## Configuration Options  
///```text 
/// 
///#[interthread::example( 
///   
///    mod ✔
///    main 
///
///    (   
///        path = "path/to/file.rs" ❗️ 
///
///        expand(actor,group) ✔
///    )
/// )]
/// 
/// 
/// default:    ✔
/// required:   ❗️
/// 
/// 
///```
/// 
/// # Arguments
/// 
/// - [`path`](#path)
/// - [`expand`](#expand) (default)
/// 
/// # path
/// 
/// 
/// The `path` argument is a required parameter of the [`example`](./attr.example.html) macro.
/// It expects the path to the file that needs to be expanded.
/// 
/// This argument is essential as it specifies the target file 
/// for code expansion.
/// 
/// ! One more time [`example`](./attr.example.html) macro can be 
/// placed on any item in any file within your `src` directory.
/// 
///  
/// # expand
/// 
/// This argument allows the user to specify which 
/// `interthread` macros to expand. 
/// 
/// By default, the value of `expand` includes 
/// the [`actor`](./attr.actor.html) and 
/// [`group`](./attr.group.html) macros.
/// 
/// For example, if you want to expand only the
/// [`actor`](./attr.actor.html) macro in the generated 
/// example code, you can use the following attribute:
/// 
/// ```rust
/// #[example(path="my_file.rs",expand(actor))]
/// ```
/// This will generate an example code file that includes 
/// the expanded code of the [`actor`](./attr.actor.html) macro,
/// while excluding other macros like 
/// [`group`](./attr.group.html).
/// 
 

#[proc_macro_error::proc_macro_error]
#[proc_macro_attribute]
pub fn example( attr: proc_macro::TokenStream, _item: proc_macro::TokenStream ) -> proc_macro::TokenStream {

    let mut eaa   = attribute::ExampleAttributeArguments::default();

    let aaa_parser = 
    syn::meta::parser(|meta| eaa.parse(meta));
    syn::parse_macro_input!(attr with aaa_parser);


    let (file, lib)  = file::expand_macros(&eaa.get_path(),&eaa.expand);

    let some_lib = if eaa.main { Some(lib)} else { None };

    let path = show::example_show(file, &eaa.get_path(), some_lib );

    let msg = format!("The file has been SUCCESSFULLY created at {}",path.to_string_lossy());
    let note  = "To avoid potential issues and improve maintainability, it is recommended to comment out the macro after its successful execution. To proceed, please comment out the macro and re-run the compilation.";
    
    proc_macro_error::abort!( proc_macro2::Span::call_site(),msg; note = note);
    
}

 
/// ## Evolves a regular object into an actor
/// 
/// The macro is placed upon an implement block of an object
///  (`struct` or `enum`),
/// which has a public or restricted method named `new` returning  `Self`.
///
/// In case if the initialization could potentially fail, 
/// the method can be named `try_new` 
/// and return `Option<Self>` or `Result<Self>`.
/// 
/// The macro will copy method signatures from all 
/// public methods that do not consume the receiver, excluding 
/// methods like `pub fn foo(self, val: u8) -> ()` where `self` 
/// is consumed. Please ensure that the 
/// receiver is defined as `&self` or `&mut self`. 
/// 
/// If only a subset of methods is required to be 
/// accessible across threads, split the `impl` block 
/// into two parts. By applying the macro to a specific block, 
/// the macro will only consider the methods within that block.
/// 
/// ## Configuration Options
///```text 
/// 
/// #[interthread::actor( 
///   
///     channel = 0          ✔ 
///               n (usize) 
/// 
///     lib     = "std"      ✔
///               "smol"
///               "tokio"
///               "async_std"
///     
///     edit    (            ✘
///               script(..)
///               live(..)
///             )            
///      
///     name    = ""         ✘
/// 
///     assoc   = false      ✔
/// 
///        id   = false      ✔
///  
/// )]
/// 
/// default:    ✔
/// no default: ✘
///
///```
///  
/// # Arguments
///  
///
/// - [`channel`](#channel)
/// - [`lib`](#lib) 
/// - [`edit`](#edit)
/// - [`file`](#file)
/// - [`name`](#name)
/// - [`assoc`](#assoc)
/// - [`id`](#id)
///
/// 
/// 
/// # channel
///
/// The `channel` argument specifies the type of channel. 
///   
/// - `0`  (default)
/// - `n` ( [`usize`] buffer size)
/// The two macros
/// ```rust
/// #[actor]
/// ```
/// and
/// ```rust
/// #[actor(channel=0)]
/// ```
/// are in fact identical, both specifying same unbounded channel.
/// 
/// When specifying an [`usize`] value for the `channel` argument 
/// in the [`actor`](./attr.actor.html) macro, such as 
/// ```rust
/// #[actor(channel=4)]
/// ```
/// the actor will use a bounded channel with a buffer size of 4.
/// This means that the channel can hold up to 4 messages in its 
/// buffer before blocking/suspending the sender.
///
/// Using a bounded channel with a specific buffer size allows 
/// for control over the memory usage and backpressure behavior 
/// of the model. When the buffer is full, any further attempts 
/// to send messages will block/suspend until there is available space. 
/// This provides a natural form of backpressure, allowing the 
/// sender to slow down or pause message production when the 
/// buffer is near capacity.
/// 
/// # lib
///
/// The `lib` argument specifies the 'async' library to use.
///
/// - `"std"` (default)
/// - `"smol"`
/// - `"tokio"`
/// - `"async_std"`
///
///## Examples
///```rust
///use interthread::actor;
///
///struct MyActor;
///
///#[actor(channel=10, lib ="tokio")]
///impl MyActor{
///    pub fn new() -> Self{Self}
///}
///#[tokio::main]
///async fn main(){
///    let my_act = MyActorLive::new();
///}
///```
/// 
/// 
/// 
/// # edit
///
/// The `edit` argument specifies the available editing options.
/// When using this argument, the macro expansion will 
/// **exclude** the code related to `edit` options 
/// allowing the user to manually implement and 
/// customize those parts according to their specific needs.
/// 
/// 
/// The SDPL Model encompasses two main structs, namely `ActorScript` and `ActorLive`.
/// Within the `edit` statement, these are referenced as `script` 
/// and `live` respectively.
/// Each struct comprises three distinct sections: definition, 
/// implementation block, and implemented traits (`def`, `imp`, and `trt`).
///
/// To modify the `foo` method within `ActorLive` methods:
/// ```rust
/// #[actor(channel = 2,
///    edit(live(imp(foo))))
/// ]
/// ```
/// For multiple methods, simply extend the list: `edit(live(imp(foo, bar)))`.
/// To edit code from both structs : `edit(script(imp(play)), live(imp(foo, bar)))`.
///
/// To add a field to `ActorLive` instance, access the definition and initiating method `new`:
/// ```rust
/// #[actor(channel = 2,
///    edit(live(def, imp(new))))
/// ]
/// ```
///
/// Note: This approach is different from pre-v1.0.0 versions of the `interthread` crate,
/// providing users with precise control over generated code. 
/// 
/// Below are the previous options and their new equivalents:  
/// 
/// - [`script`](index.html#script)  - `script(def)`
/// - [`direct`](index.html#direct)  - `script(imp(direct))`
/// - [`play`](index.html#play)      - `script(imp(play))`
/// - [`live`](index.html#live)      - `live`
/// - `live::new`                    - `live(imp(new))`
///
/// 
/// See the `file` argument which works in conjuction with `edit` for an expicit example. 
/// 
/// # file
/// This argument works in conjuction with `edit` and writes to the 
/// curent module the code omited by the `edit` argument ready for user to
/// modify it.
/// 
/// > **Note:** While it is possible to have multiple actor macros
/// within the same module, only one of the macro can have file 
/// argument active.
///  
/// ## Examples
/// 
/// Filename: main.rs
/// 
///```rust
///pub struct MyActor {
///    value: i8,
///}
/// 
/// #[actor(channel=2,file="src/main.rs",edit(script(imp(play))))]
///impl MyActor {
///
///    pub fn new( value: i8 ) -> Self {
///        Self{value}
///    }
///    pub fn increment(&mut self) -> i8{
///        self.value += 1;
///        self.value
///    }
///} 
/// 
///```
/// This is the output of the above file after compilation :
/// 
/// ```rust
///  
///pub struct MyActor {
///    value: i8,
///}
///
/// #[actor(channel=2, edit(script(imp(play))))]
///impl MyActor {
///
///    pub fn new( value: i8 ) -> Self {
///        Self{value}
///    }
///    pub fn increment(&mut self) -> i8{
///        self.value += 1;
///        self.value
///    }
///}
/// //++++++++++++++++++[ Interthread  Write to File ]+++++++++++++++++//
/// // Object Name   : MyActor  
/// // Initiated By  : #[actor(channel=2,file="src/main.rs",edit(script(imp(play))))]  
/// 
/// /*
/// impl MyActorScript {
///     pub fn play(receiver: std::sync::mpsc::Receiver<MyActorScript>, mut actor: MyActor) {
///         while let Ok(msg) = receiver.recv() {
///             msg.direct(&mut actor);
///         }
///         eprintln!("MyActor end of life ...");
///     }
/// }
/// 
/// // *///.............[ Interthread  End of Write  ].................//
/// 
/// ```
/// 
/// Now, let's explore a scenario where we want to manipulate or 
/// even return a type from the [`play`](index.html#play) 
/// component by invoking a method on the [`live`](index.html#live) 
/// component. We can easily modify the generated code to 
/// enable this functionality.
/// 
/// ## Examples
/// 
/// Filename: main.rs
/// 
///```rust
/// use std::sync::mpsc;
/// use interthread::actor;
///  
/// pub struct MyActor {
///     value: i8,
/// }
/// 
/// // this is initial macro 
/// // #[actor(channel=2,file="src/main.rs",edit(script(imp(play))))]
/// // will change to 
/// #[actor(channel=2, edit(script(imp(play))))]
/// 
/// impl MyActor {
/// 
///     pub fn new( value: i8 ) -> Self {
///         Self{value}
///     }
///     pub fn increment(&mut self) -> i8{
///         self.value += 1;
///         self.value
///     }
///     // it's safe to hack the macro in this way
///     // having `&self` as receiver along  with
///     // other things creates a `Script` variant  
///     // We'll catch it in `play` function
///     pub fn play_get_counter(&self)-> Option<u32>{
///         None
///     }
/// 
/// }
/// 
/// // we have the code of `play` component
/// // using `edit` in conjuction with `file`
/// // Initiated By  : #[actor(channel=2,file="src/main.rs",edit(script(imp(play))))]  
/// impl MyActorScript {
/// 
///     pub fn play( 
///          receiver: mpsc::Receiver<MyActorScript>,
///         mut actor: MyActor) {
///         // set a custom variable 
///         let mut call_counter = 0;
///     
///         while let Ok(msg) = receiver.recv() {
///     
///             // match incoming msgs
///             // for `play_get_counter` variant
///             match msg {
///                 // you don't have to remember the 
///                 // the name of the `Script` variant 
///                 // your text editor does it for you
///                 // so just choose the variant
///                 MyActorScript::PlayGetCounter { output  } =>
///                 { let _ = output.send(Some(call_counter));},
///                 
///                 // else as usual 
///                 _ => { msg.direct(&mut actor); }
///             }
///             call_counter += 1;
///         }
///         eprintln!("the end");
///     }
/// }
/// 
/// 
/// fn main() {
/// 
///     let my_act = MyActorLive::new(0);
///     let mut act_a = my_act.clone();
///     let mut act_b = my_act.clone();
/// 
///     let handle_a = std::thread::spawn(move || {
///         act_a.increment();
///     });
///     let handle_b = std::thread::spawn(move || {
///         act_b.increment();
///     });
///     
///     let _ = handle_a.join();
///     let _ = handle_b.join();
/// 
/// 
///     let handle_c = std::thread::spawn(move || {
/// 
///         // as usual we invoke a method on `live` instance
///         // which has the same name as on the Actor object
///         // but 
///         if let Some(counter) = my_act.play_get_counter(){
/// 
///             println!("This call never riched the `Actor`, 
///             it returns the value of total calls from the 
///             `play` function ,call_counter = {:?}",counter);
/// 
///             assert_eq!(counter, 2);
///         }
///     });
///     let _ = handle_c.join();
/// 
/// }
///```
/// 
/// # name
/// 
/// The `name` attribute allows developers to provide a 
/// custom name for `actor`, overriding the default 
/// naming conventions of the crate. This can be useful 
/// when there are naming conflicts or when a specific 
/// naming scheme is desired.  
/// 
/// - "" (default): No name specified
///
/// ## Examples
///```rust
///use interthread::actor;
/// 
///pub struct MyActor;
/// 
///#[actor(name="OtherActor")]
///impl MyActor {
///
///   pub fn new() -> Self {Self}
///}
///fn main () {
///   let other_act = OtherActorLive::new();
///}
///```
/// 
/// 
/// 
/// # assoc
/// 
/// The `assoc` option indicates whether **associated**  **functions**
/// ( also known as static methods ) that **return** a type of the actor struct are included 
/// in generated code as instance methods, allowing them to be invoked on 
/// the generated struct itself. 
///
/// - true  
/// - false (default)
/// 
///  ## Examples
///```rust
///use interthread::actor;
///pub struct Aa;
///  
/// 
///#[actor(name="Bb", assoc)]
///impl Aa {
///
///    pub fn new() -> Self { Self{} }
/// 
///    // we don't have a `&self`
///    // receiver 
///    pub fn is_even( n: u8 ) -> bool {
///        n % 2 == 0
///    }
///}
///
///fn main() {
///    
///    let bb = BbLive::new();
/// 
///    // but we can call it 
///    // as if there was one   
///    assert_eq!(bb.is_even(84), Aa::is_even(84));
///}
///
///```
/// # id
/// 
/// The generated code is designed to 
/// compile successfully on Rust versions as early as 1.63.0.
/// 
/// If this argument is set to `true`, the following 
/// additions and implementations are generated :
/// 
/// 
/// Within the [`live`](index.html#live) struct definition, the following
/// fields are generated:
/// 
/// - `pub debut: std::time::SystemTime`
/// - `pub name: String`
/// 
/// The following traits are implemented for the [`live`](index.html#live) struct:
/// 
/// - `PartialEq`
/// - `PartialOrd`
/// - `Eq`
/// - `Ord`
/// 
/// These traits allow for equality and ordering 
/// comparisons based on the `debut`value.
/// The `name` field is provided for user needs only and is not 
/// taken into account when performing comparisons. 
/// It serves as a descriptive attribute or label 
/// associated with each instance of the live struct.
/// 
/// In the [`script`](index.html#script) struct implementation block, which 
/// encapsulates the functionality of the model,
/// a static method named `debut` is generated. This 
/// method returns the current system time and is commonly 
/// used to set the `debut` field when initializing 
/// instances of the [`live`](index.html#live) struct.
/// 
/// - true  
/// - false (default)
/// 
/// Use macro [`example`](./attr.example.html) to see the generated code.
/// 
/// 
/// ## Examples
///  
///```rust
///use std::thread::spawn;
///pub struct MyActor ;
///
///#[interthread::actor(channel=2, id)] 
///impl MyActor {
///    pub fn new() -> Self { Self{} } 
///}
///fn main() {
///
///    let actor_1 = MyActorLive::new();
///
///    let handle_2 = spawn( move || { 
///        MyActorLive::new()
///    });
///    let actor_2 = handle_2.join().unwrap();
///
///    let handle_3 = spawn( move || {
///        MyActorLive::new()
///    });
///    let actor_3 = handle_3.join().unwrap();
///    
///    // they are the same type objects
///    // but serving differrent threads
///    // different actors !   
///    assert!(actor_1 != actor_2);
///    assert!(actor_2 != actor_3);
///    assert!(actor_3 != actor_1);
///
///    // since we know the order of invocation
///    // we correctly presume
///    assert_eq!(actor_1 > actor_2, true );
///    assert_eq!(actor_2 > actor_3, true );
///    assert_eq!(actor_3 < actor_1, true );
///
///    // but if we check the order by `debute` value
///    assert_eq!(actor_1.debut < actor_2.debut, true );
///    assert_eq!(actor_2.debut < actor_3.debut, true );
///    assert_eq!(actor_3.debut > actor_1.debut, true );
///    
///    // This is because the 'debut' 
///    // is a time record of initiation
///    // Charles S Chaplin (1889)
///    // Keanu Reeves      (1964)
///
///
///    // we can count `live` instances for 
///    // every model
///    use std::sync::Arc;
///    let mut a11 = actor_1.clone();
///    let mut a12 = actor_1.clone();
///
///    let mut a31 = actor_3.clone();
///
///    assert_eq!(Arc::strong_count(&actor_1.debut), 3 );
///    assert_eq!(Arc::strong_count(&actor_2.debut), 1 );
///    assert_eq!(Arc::strong_count(&actor_3.debut), 2 );
///            
///
///    // or use getter `count`                 
///    assert_eq!(actor_1.inter_get_count(), 3 );
///    assert_eq!(actor_2.inter_get_count(), 1 );
///    assert_eq!(actor_3.inter_get_count(), 2 );
///    
///
///    use std::time::SystemTime;
///
///    // getter `debut` to get its timestamp   
///    let _debut1: SystemTime = actor_1.inter_get_debut();
///
///            
///    // the name field is not taken 
///    // into account when comparison is
///    // perfomed       
///    assert!( a11 == a12);
///    assert!( a11 != a31);
///
///    a11.name = String::from("Alice");
///    a12.name = String::from("Bob");
///
///    a31.name = String::from("Alice");
///
///    assert_eq!(a11 == a12, true );
///    assert_eq!(a11 != a31, true );
///
///    // setter `name` accepts any ToString  
///    a11.inter_set_name('t');
///    a12.inter_set_name(84u32);
///    a31.inter_set_name(3.14159);
///
///    // getter `name`                      
///    assert_eq!(a11.inter_get_name(), "t" );
///    assert_eq!(a12.inter_get_name(), "84" );
///    assert_eq!(a31.inter_get_name(), "3.14159" );
///
///}
///``` 
/// 
/// 
/// 
/// 
/// Using `id` will generate fore additional
///methods on `live` struct:
/// 
/// 1. `inter_set_name(s: ToString)`: Sets the value of the 
/// name field.
/// 2. `inter_get_name() -> &str`: Retrieves the value of the 
/// name field.
/// 3. `inter_get_debut() -> std::time::SystemTime`: Retrieves
/// the value of the debut field, which represents a timestamp.
/// 4. `inter_get_count() -> usize`: Provides the strong 
/// reference count for the debut field.
///  
/// > **Note:** Additional generated methods prefixed with `inte`
///  will have the same visibility as the initiating
///  method `new` or `try_new`. 
/// 
///This convention allows 
///- easy identification in text editor methods that 
///solely manipulate the internal state of the live struct and/or 
///methods that are added by the `interthread` macros
///- it mitigates the risk of potential naming conflicts in case if there
///is or will be a custom method `get_name`
///-  helps the macro  identify methods that are intended 
///to be used within its context
///
///This section is currently under development and will
///be continued in the next version....
/// 
/// 
/// 

#[proc_macro_error::proc_macro_error]
#[proc_macro_attribute]
pub fn actor( attr: proc_macro::TokenStream, item: proc_macro::TokenStream ) -> proc_macro::TokenStream {
    
    let mac  = attribute::AAExpand::Actor;
    let item_impl = syn::parse_macro_input!(item as syn::ItemImpl);

    let mut aaa = attribute::ActorAttributeArguments::default();
    let nested  = syn::parse_macro_input!(attr with syn::punctuated::Punctuated::<syn::Meta,syn::Token![,]>::parse_terminated); 
    aaa.parse_nested(nested);
    aaa.cross_check();

    check::channels_import( &aaa.lib );

    let (code,edit) = 
    crate::actor_gen::actor_macro_generate_code( aaa.clone(), item_impl.clone(), &mac ,None);

    if let Some( aaf ) = aaa.file {
        parse::edit_write(  &aaf, item_impl, aaa.edit.is_all(), &mac, edit);
    }

    quote::quote!{#code}.into()

}

/// ## Currently under development (((
/// 
/// The `group` macro, although not currently included 
/// in the `interthread` crate.It aims to address 
/// several critical challenges encountered when
///  working with the `actor` macro:
/// 
/// - Instead of creating separate threads for each object, 
/// the `group` macro will enable the user to create an actor 
/// that represents a group of objects, consolidating 
/// their processing and execution within a single thread.
/// 
/// 
/// - In scenarios where objects are already created or imported,
/// and the user does not have the authority to implement 
/// additional methods such as  "new" or "try_new",
/// the `group` macro should offer a way to include 
/// these objects as part of the actor system.
///
/// Although the `group` macro is not currently part of the 
/// `interthread` crate, its development aims to offer a 
/// comprehensive solution to these challenges, empowering 
/// users to efficiently manage groups of objects within an 
/// actor system.
/// 
/// Check `interthread` on ['GitHub'](https://github.com/NimonSour/interthread.git)
/// 

#[proc_macro_error::proc_macro_error]
#[proc_macro_attribute]
pub fn group( _attr: proc_macro::TokenStream, _item: proc_macro::TokenStream ) -> proc_macro::TokenStream {
    let msg = "The \"group\" macro is currently under development and is not yet implemented in the `interthread` crate.";
    proc_macro_error::abort!( proc_macro2::Span::call_site(),msg );
}






